#!/bin/bash

# exit when any command fails
set -e
set -o pipefail

# assumes that the veracrypt encrypted volume has been already created 

usage () {
	echo ""
	echo "Try 'backup --help' for more information"
	exit 1
}

mount () {
	# mount the encrypted veracrypt volume
	# where the veracrypt encrypted volume will be mounted
	MOUNT_POINT=
}

dismount () {
	# unmount the veracrypt encrypted volume
	return
}

get_backup_details () {
	# path where the encrypted volume is located
	# the backup location should be a folder, therefore it should not contain a
	# slash at the end
	# TODO: check if contains slash
	BACKUP_LOCATION=./test/backup

	# list of all files and folders in the backup
	FILES=(
		"./test/docs"
		"./test/vids"
		#./test/photos"
		#./test/backup"
	)

	EXCLUDED_FILES=(
		# Note: when excluding directories, make sure NOT to use the traililng
		# slash(/) at the end of the path

		#"./test/docs"	
		"./test/vids"
	)

	FINGERPRINT_FILENAME="backup.md5sum"
	# var not used anymore, it will be replaced by [date]FINGERPRINT_FILENAME
	# according to new algorithm
	#INCOMING_FINGERPRINT_FILENAME="incoming_backup.md5sum"
}

validate_backup_details () {
	# TODO: test paths with spaces and characters that aren't POSIX standard

	if [ ! -d "$BACKUP_LOCATION" ]; then
		echo "Backup location '"$BACKUP_LOCATION"' does not exist.">&2
		usage
	fi

	# check if array is empty

	for file in "${FILES[@]}"; do
		if [ ! -d "$file" ]; then
			echo "Files "$file" do not exist.">&2
			usage
		fi
	done
}

get_backup_filename () {
	# collect and compress the list of files onto the $backup_location/YYYY-MM-dd-HHmmss_backup
	echo ".$(date +%F-%H%M%S)_backup"
}


format_files_for_backup () {
	local files_string=

	if [ "${#FILES[*]}" -eq 0 ]; then
			files_string=""
	else
		for file in "${FILES[@]}"; do	
			files_string="$FILES "$file" "
		done
	fi

	echo "$files_string"
}

format_excluded_files () {
	# tar requires that all exluded files/directories are prefixed with --excluded	
	local excluded_files_string=

	if [ "${#EXCLUDED_FILES[*]}" -eq 0 ]; then
			exluded_files_string=""
	else
		for excluded_file in "${EXCLUDED_FILES[@]}"; do	
			excluded_files_string="$excluded_files_string --exclude="$excluded_file" "
		done
	fi

	echo "$excluded_files_string"
}

create_fingerprint_initial_backup () {
	echo "Creating backup fingerprint..."	
	find $(format_files_for_backup) -type f -exec md5sum {} + | sort -k 2 > \
	"$BACKUP_LOCATION"/$FINGERPRINT_FILENAME
}

create_fingerprint_incoming_backup () {
	echo "Creating fingerprint file for incoming backup files..."
	find $(format_files_for_backup) -type f -exec md5sum {} + | sort -k 2 > \
	"$BACKUP_LOCATION/$INCOMING_FINGERPRINT_FILENAME"
}

identify_changes () {
	echo "Comparing incoming changes with existing files..."	
	# check if there is any difference at all between the files
	local diff_output="$(diff --suppress-common-lines \
		"$BACKUP_LOCATION/$FINGERPRINT_FILENAME" \
		"$BACKUP_LOCATION/$INCOMING_FINGERPRINT_FILENAME")"

	if [ "$diff_output" == "" ]; then
		echo "No changes found."
		exit 1
	else
		# added the || true because diff throws the "file not found" error message
		# and stops the script

		echo "Files that have been deleted:"
		diff --suppress-common-lines "$BACKUP_LOCATION/$FINGERPRINT_FILENAME" \
		"$BACKUP_LOCATION/$INCOMING_FINGERPRINT_FILENAME" | grep '^<' | cut -d \
		" " -f 4 || true

		echo "Files that have been added:"
		diff --suppress-common-lines "$BACKUP_LOCATION/$FINGERPRINT_FILENAME" \
		"$BACKUP_LOCATION/$INCOMING_FINGERPRINT_FILENAME" | grep '^>' | cut -d \
		" " -f 4 || true
	fi	
}


backup () {
	get_backup_details
	validate_backup_details


	# =======NEW ALGORITHM 3=============
	# creating md5sum for every backup (full and diff-incremental)
	
	# checks if there are any md5sum files in the current directory
	if [ ! -f "$BACKUP_LOCATION"/*.md5sum ]; then
		# if not makes a full backup
    	echo "Fingerprint file not found." 
		
		create_fingerprint_initial_backup

		echo "Full backup started."
		#echo " tar czpvf "$BACKUP_LOCATION"/$(get_backup_filename).tgz $(format_excluded_files) ${FILES[*]} "
		echo " tar czpvf "$BACKUP_LOCATION"/full-backup.tgz $(format_excluded_files) \
		${FILES[*]} "
		echo "Full backup completed successfully."
	
	else
		echo "Fingerprint file exists"

		# if so, takes the latest md5sum created (not modified)
		#create_fingerprint_incoming_backup
		#identify_changes

		# if new changes, then create Versioning folder
		# create a folder 
		# create then the tar file with suffix
	fi

}


case "$1" in 	
	"")				#mount
					backup
					#dismount	
					;;
	-h|--help)		usage
					return
					;;
	*)				usage
					;;
esac




